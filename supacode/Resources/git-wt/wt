#!/bin/bash
set -euo pipefail

usage() {
  cat <<'USAGE'
wt - A simple git worktree sugar

Usage:
  wt <command>

Commands:
  switch <branch> create or open a workspace
  sw <branch>     alias for switch
  exec <branch>   open a workspace and run a command
  ls              list workspaces
  rm <branch>     remove a workspace
  here            print current workspace branch
  base            print base dir
  root            print main worktree path
  completion      print shell completion
  help [command]  show help
USAGE
}

switch_usage() {
  cat <<'USAGE'
wt switch|sw <branch>

Flags:
  --from <ref>      base ref for new branch
  --base <dir>      base dir override
  --path <dir>      explicit worktree path
  --fetch           fetch remotes before resolving --from
  --copy-all        copy ignored, untracked, and modified files to new worktree
  --copy-ignored    copy gitignored files to new worktree
  --copy-untracked  copy untracked files to new worktree
  --copy-modified   copy modified files to new worktree
  -h, --help        show help
USAGE
}

exec_usage() {
  cat <<'USAGE'
wt exec <branch> -- <cmd...>

Flags:
  --from <ref>    base ref for new branch
  --base <dir>    base dir override
  --path <dir>    explicit worktree path
  --fetch         fetch remotes before resolving --from
  -h, --help      show help
USAGE
}

ls_usage() {
  cat <<'USAGE'
wt ls

Flags:
  --base <dir>    base dir override
  --plain         tab-delimited output
  --json          JSON output
  -h, --help      show help
USAGE
}

rm_usage() {
  cat <<'USAGE'
wt rm <branch>

Flags:
  -f, --force     remove even if dirty
  --base <dir>    base dir override
  -h, --help      show help
USAGE
}

here_usage() {
  cat <<'USAGE'
wt here
USAGE
}

base_usage() {
  cat <<'USAGE'
wt base
USAGE
}

root_usage() {
  cat <<'USAGE'
wt root
USAGE
}

completion_usage() {
  cat <<'USAGE'
wt completion <shell>

Shells:
  bash
  zsh
  fish
USAGE
}

die() {
  printf 'error: %s\n' "$1" >&2
  exit 1
}

require_repo() {
  git rev-parse --git-dir >/dev/null 2>&1 || die "not a git repository"
}

main_worktree_path() {
  local git_dir
  git_dir=$(git rev-parse --git-dir)
  if [[ "$git_dir" == *"/worktrees/"* ]]; then
    while read -r key value; do
      if [ "$key" = "worktree" ]; then
        printf '%s\n' "$value"
        return
      fi
    done < <(git worktree list --porcelain)
  fi
  git rev-parse --show-toplevel
}

abs_path() {
  local path="$1"
  case "$path" in
  /*) printf '%s\n' "$path" ;;
  *) printf '%s/%s\n' "$(pwd -P)" "$path" ;;
  esac
}

normalize_dir() {
  local path="$1"
  if [ "$path" != "/" ]; then
    path="${path%/}"
  fi
  printf '%s\n' "$path"
}

base_dir() {
  local root="$1"
  local override="$2"
  local chosen
  chosen="${GIT_WT_BASE:-}"
  if [ -n "$override" ]; then
    chosen="$override"
  fi
  if [ -z "$chosen" ]; then
    normalize_dir "$(abs_path "$root/.worktrees")"
    return
  fi
  case "$chosen" in
  /*) normalize_dir "$(abs_path "$chosen")" ;;
  *) normalize_dir "$(abs_path "$root/$chosen")" ;;
  esac
}

resolve_path() {
  local root="$1"
  local path="$2"
  case "$path" in
  /*) abs_path "$path" ;;
  *) abs_path "$root/$path" ;;
  esac
}

worktree_entries() {
  local root="$1"
  local path="" head="" branch=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [ -z "$line" ]; then
      if [ -n "$path" ]; then
        printf '%s\t%s\t%s\n' "$path" "$head" "$branch"
      fi
      path=""
      head=""
      branch=""
      continue
    fi
    local key value
    key=${line%% *}
    value=${line#* }
    case "$key" in
    worktree) path="$value" ;;
    HEAD) head="$value" ;;
    branch) branch="${value#refs/heads/}" ;;
    detached) branch="" ;;
    esac
  done < <(git -C "$root" worktree list --porcelain)
  if [ -n "$path" ]; then
    printf '%s\t%s\t%s\n' "$path" "$head" "$branch"
  fi
}

find_worktree_by_branch() {
  local root="$1"
  local branch="$2"
  local entry
  while IFS= read -r entry; do
    local path head name
    path=${entry%%$'\t'*}
    head=${entry#*$'\t'}
    name=${head#*$'\t'}
    head=${head%%$'\t'*}
    if [ "$name" = "$branch" ]; then
      printf '%s\n' "$path"
      return 0
    fi
  done < <(worktree_entries "$root")
  return 1
}

find_worktree_by_path() {
  local root="$1"
  local target="$2"
  local entry
  while IFS= read -r entry; do
    local path
    path=${entry%%$'\t'*}
    if [ "$path" = "$target" ]; then
      printf '%s\n' "$path"
      return 0
    fi
  done < <(worktree_entries "$root")
  return 1
}

json_escape() {
  printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'
}

list_ignored_files() {
  local root="$1"
  git -C "$root" ls-files --others --ignored --exclude-standard 2>/dev/null | sed '/^\.git\//d'
}

list_untracked_files() {
  local root="$1"
  git -C "$root" ls-files --others --exclude-standard 2>/dev/null | sed '/^\.git\//d'
}

list_modified_files() {
  local root="$1"
  git -C "$root" ls-files --modified 2>/dev/null | sed '/^\.git\//d'
}

copy_files_to_worktree() {
  local src="$1"
  local dst="$2"
  local copyignored="$3"
  local copyuntracked="$4"
  local copymodified="$5"
  local files=""
  if [ "$copyignored" -eq 1 ]; then
    files+=$(list_ignored_files "$src")$'\n'
  fi
  if [ "$copyuntracked" -eq 1 ]; then
    files+=$(list_untracked_files "$src")$'\n'
  fi
  if [ "$copymodified" -eq 1 ]; then
    files+=$(list_modified_files "$src")$'\n'
  fi
  local seen=""
  while IFS= read -r file; do
    [ -z "$file" ] && continue
    case "$seen" in *"$file"*) continue ;; esac
    seen+="$file"$'\n'
    local srcfile="$src/$file"
    local dstfile="$dst/$file"
    [ -f "$srcfile" ] || continue
    mkdir -p "$(dirname "$dstfile")"
    cp "$srcfile" "$dstfile" 2>/dev/null || true
  done <<< "$files"
}

open_path() {
  local branch="$1"
  local from="$2"
  local base_override="$3"
  local path_override="$4"
  local fetch="$5"
  local copyignored="${6:-0}"
  local copyuntracked="${7:-0}"
  local copymodified="${8:-0}"
  require_repo
  local root base path
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$base_override")
  if [ -n "$path_override" ]; then
    path=$(resolve_path "$root" "$path_override")
  else
    path=$(resolve_path "$root" "$base/$branch")
  fi
  local existing
  if existing=$(find_worktree_by_branch "$root" "$branch"); then
    printf '%s\n' "$existing"
    return 0
  fi
  if git -C "$root" show-ref --verify --quiet "refs/heads/$branch"; then
    if [ -z "$path_override" ]; then
      die "branch exists without worktree: '$branch'"
    fi
    if find_worktree_by_path "$root" "$path" >/dev/null; then
      die "worktree path already in use: '$path'"
    fi
    mkdir -p "$(dirname "$path")"
    git -C "$root" worktree add "$path" "$branch" >/dev/null 2>&1
    copy_files_to_worktree "$root" "$path" "$copyignored" "$copyuntracked" "$copymodified"
    printf '%s\n' "$path"
    return 0
  fi
  if [ "$fetch" -eq 1 ]; then
    git -C "$root" fetch >/dev/null 2>&1
  fi
  if [ -z "$from" ]; then
    from=$(git -C "$root" rev-parse HEAD)
  fi
  git -C "$root" rev-parse --verify "${from}^{commit}" >/dev/null 2>&1 || die "invalid --from ref '$from'"
  mkdir -p "$(dirname "$path")"
  git -C "$root" worktree add -b "$branch" "$path" "$from" >/dev/null 2>&1
  copy_files_to_worktree "$root" "$path" "$copyignored" "$copyuntracked" "$copymodified"
  printf '%s\n' "$path"
}

cmd_switch() {
  local from="" base_override="" path_override="" fetch=0 branch=""
  local copyignored=0 copyuntracked=0 copymodified=0
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      switch_usage
      exit 0
      ;;
    --from)
      [ -n "${2:-}" ] || die "missing value for --from"
      from="$2"
      shift
      ;;
    --from=*) from="${1#--from=}" ;;
    --base)
      [ -n "${2:-}" ] || die "missing value for --base"
      base_override="$2"
      shift
      ;;
    --base=*) base_override="${1#--base=}" ;;
    --path)
      [ -n "${2:-}" ] || die "missing value for --path"
      path_override="$2"
      shift
      ;;
    --path=*) path_override="${1#--path=}" ;;
    --fetch) fetch=1 ;;
    --copy-all) copyignored=1; copyuntracked=1; copymodified=1 ;;
    --copy-ignored) copyignored=1 ;;
    --copy-untracked) copyuntracked=1 ;;
    --copy-modified) copymodified=1 ;;
    --*) die "unknown flag '$1'" ;;
    *) if [ -z "$branch" ]; then branch="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  open_path "$branch" "$from" "$base_override" "$path_override" "$fetch" "$copyignored" "$copyuntracked" "$copymodified"
}

cmd_exec() {
  local from="" base_override="" path_override="" fetch=0 branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      exec_usage
      exit 0
      ;;
    --from)
      [ -n "${2:-}" ] || die "missing value for --from"
      from="$2"
      shift
      ;;
    --from=*) from="${1#--from=}" ;;
    --base)
      [ -n "${2:-}" ] || die "missing value for --base"
      base_override="$2"
      shift
      ;;
    --base=*) base_override="${1#--base=}" ;;
    --path)
      [ -n "${2:-}" ] || die "missing value for --path"
      path_override="$2"
      shift
      ;;
    --path=*) path_override="${1#--path=}" ;;
    --fetch) fetch=1 ;;
    --) shift; break ;;
    --*) die "unknown flag '$1'" ;;
    *)
      if [ -z "$branch" ]; then
        branch="$1"
      else
        die "missing -- before command"
      fi
      ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  [ "$#" -gt 0 ] || die "missing command"
  local path
  path=$(open_path "$branch" "$from" "$base_override" "$path_override" "$fetch")
  cd "$path"
  exec "$@"
}

cmd_ls() {
  local base_override="" plain=0 json=0
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      ls_usage
      exit 0
      ;;
    --base)
      [ -n "${2:-}" ] || die "missing value for --base"
      base_override="$2"
      shift
      ;;
    --base=*) base_override="${1#--base=}" ;;
    --plain) plain=1 ;;
    --json) json=1 ;;
    --*) die "unknown flag '$1'" ;;
    *) die "unexpected argument '$1'" ;;
    esac
    shift
  done
  require_repo
  local root base
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$base_override")
  if [ "$plain" -eq 1 ] && [ "$json" -eq 1 ]; then
    die "cannot use --plain and --json together"
  fi
  local mode="table"
  if [ "$plain" -eq 1 ]; then
    mode="plain"
  elif [ "$json" -eq 1 ]; then
    mode="json"
  elif [ ! -t 1 ]; then
    mode="plain"
  fi
  local entries
  entries=$(worktree_entries "$root")
  local filtered=""
  while IFS= read -r entry; do
    [ -n "$entry" ] || continue
    local path head branch
    path=${entry%%$'\t'*}
    head=${entry#*$'\t'}
    branch=${head#*$'\t'}
    head=${head%%$'\t'*}
    case "$path" in
    "$base"/*)
      filtered+="$branch\t$path\t$head\n"
      ;;
    esac
  done <<<"$entries"
  case "$mode" in
  json)
    printf '['
    local first=1
    while IFS=$'\t' read -r branch path head; do
      [ -n "$branch" ] || continue
      if [ "$first" -eq 0 ]; then
        printf ','
      fi
      first=0
      printf '{"branch":"%s","path":"%s","head":"%s"}' "$(json_escape "$branch")" "$(json_escape "$path")" "$(json_escape "$head")"
    done <<<"$(printf '%b' "$filtered")"
    printf ']\n'
    ;;
  plain)
    printf '%b' "$filtered" | awk -F'\t' 'NF>=2 {print $1"\t"$2}'
    ;;
  table)
    printf '%b' "$filtered" | awk -F'\t' 'NF>=3 {printf "%-30s %-60s %s\n", $1, $2, $3}'
    ;;
  esac
}

cmd_rm() {
  local force=0 base_override="" branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      rm_usage
      exit 0
      ;;
    -f | --force) force=1 ;;
    --base)
      [ -n "${2:-}" ] || die "missing value for --base"
      base_override="$2"
      shift
      ;;
    --base=*) base_override="${1#--base=}" ;;
    --*) die "unknown flag '$1'" ;;
    *) if [ -z "$branch" ]; then branch="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  require_repo
  local root base path
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$base_override")
  if ! path=$(find_worktree_by_branch "$root" "$branch"); then
    die "workspace not found: '$branch'"
  fi
  case "$path" in
  "$base"/*) ;;
  *) die "workspace not under base: '$path'" ;;
  esac
  local dirty
  dirty=$(git -C "$path" status --porcelain)
  if [ -n "$dirty" ] && [ "$force" -eq 0 ]; then
    if [ -t 0 ]; then
      printf "workspace '%s' has uncommitted changes. remove anyway? [y/N] " "$branch" >&2
      read -r answer
      case "$answer" in
      y | Y | yes | YES) force=1 ;;
      *) exit 1 ;;
      esac
    else
      die "workspace dirty: '$branch'"
    fi
  fi
  if [ "$force" -eq 1 ]; then
    git -C "$root" worktree remove --force "$path" >/dev/null 2>&1
  else
    git -C "$root" worktree remove "$path" >/dev/null 2>&1
  fi
  if [ "$force" -eq 1 ]; then
    git -C "$root" branch -D "$branch" >/dev/null 2>&1
  else
    git -C "$root" branch -d "$branch" >/dev/null 2>&1
  fi
  printf '%s\n' "$path"
}

cmd_here() {
  require_repo
  local root base current
  root=$(main_worktree_path)
  base=$(base_dir "$root" "")
  current=$(git rev-parse --show-toplevel)
  case "$current" in
  "$base"/*) ;;
  *) exit 1 ;;
  esac
  local entry
  while IFS= read -r entry; do
    local path head name
    path=${entry%%$'\t'*}
    head=${entry#*$'\t'}
    name=${head#*$'\t'}
    if [ "$path" = "$current" ]; then
      if [ -n "$name" ]; then
        printf '%s\n' "$name"
        exit 0
      fi
    fi
  done < <(worktree_entries "$root")
  exit 1
}

cmd_base() {
  require_repo
  local root base
  root=$(main_worktree_path)
  base=$(base_dir "$root" "")
  printf '%s\n' "$base"
}

cmd_root() {
  require_repo
  main_worktree_path
}

completion_bash() {
  local commands
  commands="switch sw exec ls rm here base root help completion"
  cat <<EOF
command -v wt >/dev/null 2>&1 || return 0

wt() {
  case "\$1" in
    switch|sw)
      local i
      for i in "\$@"; do
        case "\$i" in
          -h|--help)
            command wt "\$@"
            return \$?
            ;;
        esac
      done
      local out path
      out=\$(command wt "\$@")
      local rc=\$?
      path=\$(printf '%s\n' "\$out" | tail -n 1)
      if [[ \$rc -eq 0 && -n "\$path" && -d "\$path" ]]; then
        if [[ "\$out" != "\$path" ]]; then
          printf '%s\n' "\$out" | sed '\$d'
        fi
        cd "\$path"
      else
        [[ -n "\$out" ]] && printf '%s\n' "\$out"
        return \$rc
      fi
      ;;
    *)
      command wt "\$@"
      ;;
  esac
}

__wt_branches() {
  git rev-parse --git-dir >/dev/null 2>&1 || return 0
  git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
}

_wt_complete() {
  local cur prev cmd
  cur="\${COMP_WORDS[COMP_CWORD]}"
  prev="\${COMP_WORDS[COMP_CWORD-1]}"
  cmd="\${COMP_WORDS[1]}"
  compopt +o default +o bashdefault 2>/dev/null
  local commands="$commands"
  local flags=""
  local i
  for i in "\${COMP_WORDS[@]}"; do
    if [ "\$i" = "--" ]; then
      return 0
    fi
  done
  if [ "\$COMP_CWORD" -eq 1 ]; then
    COMPREPLY=( \$(compgen -W "\$commands" -- "\$cur") )
    return 0
  fi
  case "\$cmd" in
    switch|sw)
      flags="--from --base --path --fetch --copy-all --copy-ignored --copy-untracked --copy-modified -h --help"
      case "\$prev" in
        --from|--base|--path) return 0 ;;
      esac
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    exec)
      flags="--from --base --path --fetch -h --help --"
      case "\$prev" in
        --from|--base|--path|--) return 0 ;;
      esac
      if [ "\$COMP_CWORD" -eq 2 ]; then
        COMPREPLY=( \$(compgen -W "\$(__wt_branches)" -- "\$cur") )
      else
        COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      fi
      ;;
    rm)
      flags="--base -f --force -h --help"
      case "\$prev" in
        --base) return 0 ;;
      esac
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    ls)
      flags="--base --plain --json -h --help"
      case "\$prev" in
        --base) return 0 ;;
      esac
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    here|base|root)
      flags="-h --help"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    help)
      flags="switch sw exec ls rm here base root help completion"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    completion)
      flags="bash zsh fish"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
  esac
}

complete -F _wt_complete wt
EOF
}

completion_zsh() {
  cat <<EOF
command -v wt >/dev/null 2>&1 || return 0

wt() {
  case "\$1" in
    switch|sw)
      local i
      for i in "\$@"; do
        case "\$i" in
          -h|--help)
            command wt "\$@"
            return \$?
            ;;
        esac
      done
      local out path
      out=\$(command wt "\$@")
      local rc=\$?
      path=\$(printf '%s\n' "\$out" | tail -n 1)
      if [[ \$rc -eq 0 && -n "\$path" && -d "\$path" ]]; then
        if [[ "\$out" != "\$path" ]]; then
          printf '%s\n' "\$out" | sed '\$d'
        fi
        cd "\$path"
      else
        [[ -n "\$out" ]] && printf '%s\n' "\$out"
        return \$rc
      fi
      ;;
    *)
      command wt "\$@"
      ;;
  esac
}

__wt_branches() {
  git rev-parse --git-dir >/dev/null 2>&1 || return 0
  git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
}

_wt() {
  local -a subcmds subdescs switch_flags switch_descs exec_flags exec_descs ls_flags ls_descs rm_flags rm_descs hb_flags hb_descs
  subcmds=(switch sw exec ls rm here base root help completion)
  subdescs=(
    "create or open a workspace"
    "alias for switch"
    "open a workspace and run a command"
    "list workspaces"
    "remove a workspace"
    "print current workspace branch"
    "print base dir"
    "print main worktree path"
    "show help"
    "print shell completion"
  )
  switch_flags=(--from --base --path --fetch --copy-all --copy-ignored --copy-untracked --copy-modified -h --help)
  switch_descs=("base ref for new branch" "base dir override" "explicit worktree path" "fetch remotes before resolving --from" "copy ignored, untracked, and modified files to new worktree" "copy gitignored files to new worktree" "copy untracked files to new worktree" "copy modified files to new worktree" "show help" "show help")
  exec_flags=(--from --base --path --fetch -h --help --)
  exec_descs=("base ref for new branch" "base dir override" "explicit worktree path" "fetch remotes before resolving --from" "show help" "show help" "end of flags")
  ls_flags=(--base --plain --json -h --help)
  ls_descs=("base dir override" "tab-delimited output" "JSON output" "show help" "show help")
  rm_flags=(--base -f --force -h --help)
  rm_descs=("base dir override" "remove even if dirty" "remove even if dirty" "show help" "show help")
  hb_flags=(-h --help)
  hb_descs=("show help" "show help")
  if (( CURRENT == 2 )); then
    compadd -d subdescs -- \$subcmds
    return 0
  fi
  local cmd=\${words[2]}
  case "\$cmd" in
    switch|sw)
      if [[ "\${words[CURRENT-1]}" == --from || "\${words[CURRENT-1]}" == --base || "\${words[CURRENT-1]}" == --path ]]; then
        return 0
      fi
      compadd -d switch_descs -- \$switch_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    exec)
      if [[ "\${words[CURRENT-1]}" == --from || "\${words[CURRENT-1]}" == --base || "\${words[CURRENT-1]}" == --path || "\${words[CURRENT-1]}" == -- ]]; then
        return 0
      fi
      if (( CURRENT == 3 )); then
        compadd -- \${(f)"\$(__wt_branches)"}
      else
        compadd -d exec_descs -- \$exec_flags
      fi
      return 0
      ;;
    rm)
      if [[ "\${words[CURRENT-1]}" == --base ]]; then
        return 0
      fi
      compadd -d rm_descs -- \$rm_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    ls)
      if [[ "\${words[CURRENT-1]}" == --base ]]; then
        return 0
      fi
      compadd -d ls_descs -- \$ls_flags
      return 0
      ;;
    here|base|root)
      compadd -d hb_descs -- \$hb_flags
      return 0
      ;;
    help)
      compadd -d subdescs -- \$subcmds
      return 0
      ;;
    completion)
      compadd -- bash zsh fish
      return 0
      ;;
  esac
  return 0
}

compdef _wt wt
EOF
}

completion_fish() {
  cat <<'EOF'
type -q wt; or return

function wt
  if test "$argv[1]" = "switch" -o "$argv[1]" = "sw"
    if contains -- -h --help $argv
      command wt $argv
      return $status
    end
    set -g __wt_rc 0
    set -l out (begin
      command wt $argv
      set -g __wt_rc $status
    end | string collect | string trim --right)
    set -l rc $__wt_rc
    set -e __wt_rc
    set -l out_lines (string split -- "\n" -- $out)
    set -l path $out_lines[-1]
    if test $rc -eq 0 -a -n "$path" -a -d "$path"
      if test (count $out_lines) -gt 1
        printf '%s\n' $out_lines[1..-2]
      end
      cd "$path"
    else
      test -n "$out"; and printf '%s\n' "$out"
      return $rc
    end
  else
    command wt $argv
  end
end

function __wt_branches
  command git rev-parse --git-dir >/dev/null 2>&1
  or return
  command git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
end

complete -c wt -f
complete -c wt -n '__fish_use_subcommand' -a switch -d 'create or open a workspace'
complete -c wt -n '__fish_use_subcommand' -a sw -d 'alias for switch'
complete -c wt -n '__fish_use_subcommand' -a exec -d 'open a workspace and run a command'
complete -c wt -n '__fish_use_subcommand' -a ls -d 'list workspaces'
complete -c wt -n '__fish_use_subcommand' -a rm -d 'remove a workspace'
complete -c wt -n '__fish_use_subcommand' -a here -d 'print current workspace branch'
complete -c wt -n '__fish_use_subcommand' -a base -d 'print base dir'
complete -c wt -n '__fish_use_subcommand' -a root -d 'print main worktree path'
complete -c wt -n '__fish_use_subcommand' -a help -d 'show help'
complete -c wt -n '__fish_use_subcommand' -a completion -d 'print shell completion'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec rm' -a '(__wt_branches)'

complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l from -r -d 'base ref for new branch'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l base -r -d 'base dir override'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l path -r -d 'explicit worktree path'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l fetch -d 'fetch remotes before resolving --from'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -s h -l help -d 'show help'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-all -d 'copy ignored, untracked, and modified files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-ignored -d 'copy gitignored files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-untracked -d 'copy untracked files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-modified -d 'copy modified files to new worktree'

complete -c wt -n '__fish_seen_subcommand_from ls' -l base -r -d 'base dir override'
complete -c wt -n '__fish_seen_subcommand_from ls' -l plain -d 'tab-delimited output'
complete -c wt -n '__fish_seen_subcommand_from ls' -l json -d 'JSON output'
complete -c wt -n '__fish_seen_subcommand_from ls' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from rm' -l base -r -d 'base dir override'
complete -c wt -n '__fish_seen_subcommand_from rm' -s f -l force -d 'remove even if dirty'
complete -c wt -n '__fish_seen_subcommand_from rm' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from help' -a switch -d 'create or open a workspace'
complete -c wt -n '__fish_seen_subcommand_from help' -a sw -d 'alias for switch'
complete -c wt -n '__fish_seen_subcommand_from help' -a exec -d 'open a workspace and run a command'
complete -c wt -n '__fish_seen_subcommand_from help' -a ls -d 'list workspaces'
complete -c wt -n '__fish_seen_subcommand_from help' -a rm -d 'remove a workspace'
complete -c wt -n '__fish_seen_subcommand_from help' -a here -d 'print current workspace branch'
complete -c wt -n '__fish_seen_subcommand_from help' -a base -d 'print base dir'
complete -c wt -n '__fish_seen_subcommand_from help' -a root -d 'print main worktree path'
complete -c wt -n '__fish_seen_subcommand_from help' -a help -d 'show help'
complete -c wt -n '__fish_seen_subcommand_from help' -a completion -d 'print shell completion'
complete -c wt -n '__fish_seen_subcommand_from completion' -a 'bash zsh fish'
EOF
}

cmd_completion() {
  if [ "$#" -eq 0 ]; then
    completion_usage
    exit 1
  fi
  case "$1" in
    bash) completion_bash ;;
    zsh) completion_zsh ;;
    fish) completion_fish ;;
    *) die "unknown shell '$1'" ;;
  esac
}

cmd_help() {
  if [ "$#" -eq 0 ]; then
    usage
    exit 0
  fi
  case "$1" in
  switch | sw) switch_usage ;;
  exec) exec_usage ;;
  ls) ls_usage ;;
  rm) rm_usage ;;
  here) here_usage ;;
  base) base_usage ;;
  root) root_usage ;;
  completion) completion_usage ;;
  help) usage ;;
  *) die "unknown command '$1'" ;;
  esac
}

case "${1:-}" in
"")
  usage
  exit 1
  ;;
-h | --help)
  usage
  exit 0
  ;;
help)
  shift
  cmd_help "$@"
  ;;
switch)
  shift
  cmd_switch "$@"
  ;;
sw)
  shift
  cmd_switch "$@"
  ;;
exec)
  shift
  cmd_exec "$@"
  ;;
ls)
  shift
  cmd_ls "$@"
  ;;
rm)
  shift
  cmd_rm "$@"
  ;;
here)
  shift
  cmd_here "$@"
  ;;
base)
  shift
  cmd_base "$@"
  ;;
root)
  shift
  cmd_root "$@"
  ;;
completion)
  shift
  cmd_completion "$@"
  ;;
*) die "unknown command '$1'" ;;
esac
